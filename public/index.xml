<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>NA-TRANSFER</title>
    <link>http://localhost:1313/</link>
    <description>NA-TRANSFER</description>
    <generator>Hugo 0.136.5 &amp; FixIt v0.3.13</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 29 Oct 2024 17:48:28 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Bitcask存储引擎</title>
      <link>http://localhost:1313/posts/294fa0a/</link>
      <pubDate>Tue, 29 Oct 2024 17:48:28 +0800</pubDate>
      <guid>http://localhost:1313/posts/294fa0a/</guid>
      <category domain="http://localhost:1313/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category>
      <description><![CDATA[&lt;h2 id=&#34;背景介绍&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;背景介绍&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%e8%83%8c%e6%99%af%e4%bb%8b%e7%bb%8d&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;为了解决分布式数据库&lt;a href=&#34;https://riak.com/index.html&#34;target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Riak&lt;/a&gt;高性能、低延迟的本地存储需求，Riak设计了Bitcask存储引擎，能够快速读写、处理大数据集、具备容灾能力且易于备份和恢复。Bitcask存储引擎的特点有:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;高性能读写&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;提供低读写延迟和高随机写吞吐率。&lt;/li&gt;&#xA;&lt;li&gt;在重访问负载下保持可预测的行为。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;大规模数据处理&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;处理远超内存的数据集而不降低性能。&lt;/li&gt;&#xA;&lt;li&gt;确保在大数据量下的高效运行和稳定性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;崩溃恢复与数据完整性&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;系统崩溃友好，支持快速恢复且不丢失数据。&lt;/li&gt;&#xA;&lt;li&gt;提供简便的备份和恢复机制，确保数据安全。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;简洁性与易维护性&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;代码格式和数据结构设计简洁易懂，便于维护和扩展。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;存储结构&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;存储结构&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;Bitcask架构简单，主要由：内存中键目录（keydir）和数据文件（data file）组成，其中数据文件包括活跃数据文件（active data file）和旧数据文件（older data file）。&lt;/p&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/database/bitcask-strcture.png&#34; alt=&#34;图1 bitcask存储结构&#34; srcset=&#34;http://localhost:1313/images/database/bitcask-strcture.png?size=small, http://localhost:1313/images/database/bitcask-strcture.png?size=medium 1.5x, http://localhost:1313/images/database/bitcask-strcture.png?size=large 2x&#34; data-title=&#34;图1 bitcask存储结构&#34; style=&#34;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;figcaption class=&#34;image-caption&#34;&gt;图1 bitcask存储结构&lt;/figcaption&gt;&#xD;&#xA;  &lt;/figure&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;数据文件&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;数据文件&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%e6%95%b0%e6%8d%ae%e6%96%87%e4%bb%b6&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;数据文件存在于磁盘上，组成了一个Bitcask实例目录，同一时刻只允许一个操作系统进程对其进行写操作。任何时刻，目录中只有一个文件是“活动”的，用于写入新数据，并且只通过追加方式写入。当现有活跃文件达到一定大小阈值时，会被关闭并创建一个新的活跃文件。一旦文件被关闭，它就成为不可变的，永远不会再被打开进行写操作。&lt;/p&gt;&#xA;&lt;p&gt;每个数据文件都由若干个键值对条目组成。每个键值对条目格式简单，包括时间戳、键长度、值长度、键和值。&lt;/p&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/database/bitcask-kv-record-strcture.png&#34; alt=&#34;图2  键值对条目结构&#34; srcset=&#34;http://localhost:1313/images/database/bitcask-kv-record-strcture.png?size=small, http://localhost:1313/images/database/bitcask-kv-record-strcture.png?size=medium 1.5x, http://localhost:1313/images/database/bitcask-kv-record-strcture.png?size=large 2x&#34; data-title=&#34;图2  键值对条目结构&#34; style=&#34;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;figcaption class=&#34;image-caption&#34;&gt;图2  键值对条目结构&lt;/figcaption&gt;&#xD;&#xA;  &lt;/figure&gt;&lt;/p&gt;&#xA;&lt;p&gt;每次写入时，根据待插入的键值对数据生成一个新的条目，将条目追加到活动文件中，所以数据文件其实是这些条目的线性序列。&lt;/p&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/database/bitcask-datafile-inner-strcture.png&#34; alt=&#34;图3  数据文件内部逻辑结构&#34; srcset=&#34;http://localhost:1313/images/database/bitcask-datafile-inner-strcture.png?size=small, http://localhost:1313/images/database/bitcask-datafile-inner-strcture.png?size=medium 1.5x, http://localhost:1313/images/database/bitcask-datafile-inner-strcture.png?size=large 2x&#34; data-title=&#34;图3  数据文件内部逻辑结构&#34; style=&#34;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;figcaption class=&#34;image-caption&#34;&gt;图3  数据文件内部逻辑结构&lt;/figcaption&gt;&#xD;&#xA;  &lt;/figure&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;键目录&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;键目录&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%e9%94%ae%e7%9b%ae%e5%bd%95&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;键目录是位于内存中的一张哈希表，存着所有数据文件每个键的位置信息，包括该键最近写入的文件id、值大小、偏移量和时间戳。&lt;/p&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/database/bitcask-keydir-logical-strcture.png&#34; alt=&#34;图4  键目录逻辑结构&#34; srcset=&#34;http://localhost:1313/images/database/bitcask-keydir-logical-strcture.png?size=small, http://localhost:1313/images/database/bitcask-keydir-logical-strcture.png?size=medium 1.5x, http://localhost:1313/images/database/bitcask-keydir-logical-strcture.png?size=large 2x&#34; data-title=&#34;图4  键目录逻辑结构&#34; style=&#34;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;figcaption class=&#34;image-caption&#34;&gt;图4  键目录逻辑结构&lt;/figcaption&gt;&#xD;&#xA;  &lt;/figure&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;机制设计&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;机制设计&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%e6%9c%ba%e5%88%b6%e8%ae%be%e8%ae%a1&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;Bitcask常见操作有打开数据实例、读写数据、合并旧数据文件以及备份恢复数据。&lt;/p&gt;&#xA;&lt;h3 id=&#34;打开数据实例&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;打开数据实例&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%e6%89%93%e5%bc%80%e6%95%b0%e6%8d%ae%e5%ae%9e%e4%be%8b&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;Bitcask打开数据实例的流程如下。&lt;/p&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/database/biscask-open.png&#34; alt=&#34;图5  bitcask打开数据实例&#34; srcset=&#34;http://localhost:1313/images/database/biscask-open.png?size=small, http://localhost:1313/images/database/biscask-open.png?size=medium 1.5x, http://localhost:1313/images/database/biscask-open.png?size=large 2x&#34; data-title=&#34;图5  bitcask打开数据实例&#34; style=&#34;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;figcaption class=&#34;image-caption&#34;&gt;图5  bitcask打开数据实例&lt;/figcaption&gt;&#xD;&#xA;  &lt;/figure&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;初始化 BitCask 实例&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;检查要打开的数据目录是否存在，不存在则创建新的数据目录，否则打开当前数据目录。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;加载键目录（Keydir）&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;初始化内存中的必要组件-键目录（keydir），用于快速查找键值对&lt;/li&gt;&#xA;&lt;li&gt;提示文件是 Bitcask 用于加速重启时键目录加载的辅助文件,存储了键的元数据，如果有提示文件存在，则会优先从提示文件中加载键目录，这样可以大大减少重启时的加载时间&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;打开数据文件&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;打开所有需要的数据文件，包括当前的活动文件和历史文件。对于每个文件，Bitcask 会检查文件的完整性，确保没有损坏。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;启动后台任务&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;启动必要的后台任务，如定期合并（merge）旧的数据文件，以减少磁盘空间的使用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;准备写入&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;初始化写入缓冲区，准备接受新的写入请求。如果需要，创建一个新的数据文件，作为当前的活动写入文件。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;完成打开&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;完成所有初始化步骤后，Bitcask 实例进入正常工作状态，可以接受读写请求。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;读写流程&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;读写流程&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%e8%af%bb%e5%86%99%e6%b5%81%e7%a8%8b&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;Bitcask读写流程如下图所示。&#xA;&lt;figure&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/database/bitcask-rw-flow.png&#34; alt=&#34;图6  bitcask读写流程&#34; srcset=&#34;http://localhost:1313/images/database/bitcask-rw-flow.png?size=small, http://localhost:1313/images/database/bitcask-rw-flow.png?size=medium 1.5x, http://localhost:1313/images/database/bitcask-rw-flow.png?size=large 2x&#34; data-title=&#34;图6  bitcask读写流程&#34; style=&#34;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;figcaption class=&#34;image-caption&#34;&gt;图6  bitcask读写流程&lt;/figcaption&gt;&#xD;&#xA;  &lt;/figure&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;读操作&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;读操作&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%e8%af%bb%e6%93%8d%e4%bd%9c&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&lt;p&gt;Bitcask读操作的流程如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;查找键值&lt;/strong&gt;：首先，Bitcask 会在内存中的 &lt;code&gt;keydir&lt;/code&gt; 中查找给定的键；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;读取数据&lt;/strong&gt;：根据 &lt;code&gt;keydir&lt;/code&gt; 中查找到的信息（文件 ID、位置和大小），直接从磁盘上的数据文件中读取数据。由于 &lt;code&gt;keydir&lt;/code&gt; 中已经包含了数据的准确位置，因此读取操作只需要一次磁盘寻道；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;利用操作系统缓存&lt;/strong&gt;：在许多情况下，操作系统的文件系统读取缓存会使得这一操作比预期的更快。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;所以Bitcask的读取操作非常高效，只需要一次磁盘寻道，并且可以利用操作系统的缓存来加速读取过程。&lt;/p&gt;&#xA;&lt;h4 id=&#34;写操作&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;写操作&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%e5%86%99%e6%93%8d%e4%bd%9c&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&lt;p&gt;Bitcask写操作的流程如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;打开 Bitcask 实例&lt;/strong&gt;：调用 &lt;code&gt;bitcask:open(DirectoryName, Opts)&lt;/code&gt; 打开或创建一个 Bitcask 数据存储。如果目录已有实例被打开，新进程将共享该实例的 &lt;code&gt;keydir&lt;/code&gt;；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;写入数据&lt;/strong&gt;：通过 &lt;code&gt;bitcask:put(BitCaskHandle, Key, Value)&lt;/code&gt; 将键值对追加写入当前的“活跃文件”中；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;更新 keydir&lt;/strong&gt;：写入完成后，内存中的 &lt;code&gt;keydir&lt;/code&gt; 被更新，以记录最新数据的位置和大小；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;同步数据&lt;/strong&gt;（可选）：如果设置了 &lt;code&gt;sync_on_put&lt;/code&gt; 选项，写入后会同步数据到磁盘，确保持久化；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;关闭实例&lt;/strong&gt;（可选）：完成所有写入操作后，可以调用 &lt;code&gt;bitcask:close(BitCaskHandle)&lt;/code&gt; 关闭数据存储，并确保数据被完全写入磁盘。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;删除是一种特殊的写操作。删除操作流程如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;用户请求删除&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户发起删除某个键的请求。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;写入删除标记&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在日志中追加一条记录，表示要删除该键。&lt;/li&gt;&#xA;&lt;li&gt;更新 &lt;code&gt;key-directory&lt;/code&gt;（键目录），标记该键为已删除。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;完成删除请求&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对用户返回删除成功的响应。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;等待合并过程&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定期或在合适的时机，执行后台的合并与清理过程。&lt;/li&gt;&#xA;&lt;li&gt;在合并过程中，扫描旧的日志文件。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;合并操作&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将未被删除的键值对与新的键值对写入新的合并文件。&lt;/li&gt;&#xA;&lt;li&gt;忽略已标记为删除的键。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;更新数据文件&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;更新存储路径，替换旧的日志文件为新的合并文件。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;清理旧文件&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;删除旧的日志文件，释放磁盘空间。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/database/bitcask-delete-flow.png&#34; alt=&#34;图6  bitcask删除流程&#34; srcset=&#34;http://localhost:1313/images/database/bitcask-delete-flow.png?size=small, http://localhost:1313/images/database/bitcask-delete-flow.png?size=medium 1.5x, http://localhost:1313/images/database/bitcask-delete-flow.png?size=large 2x&#34; data-title=&#34;图6  bitcask删除流程&#34; style=&#34;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;figcaption class=&#34;image-caption&#34;&gt;图6  bitcask删除流程&lt;/figcaption&gt;&#xD;&#xA;  &lt;/figure&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;合并过程&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;合并过程&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%e5%90%88%e5%b9%b6%e8%bf%87%e7%a8%8b&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;在合并过程中，Bitcask 通过以下步骤生成一组新的数据文件，并丢弃旧的、过时的数据条目：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;读取非活跃文件&lt;/strong&gt; ：Bitcask 首先会读取所有非活跃文件（即旧文件）。这些文件包含了所有历史写入的数据条目。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;构建键的最新版本映射&lt;/strong&gt; ：Bitcask 会遍历每个非活跃文件中的所有数据条目，并构建一个映射（map），该映射记录了每个键的最新版本。这个映射会覆盖旧版本的数据条目。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;写入新数据文件&lt;/strong&gt; ：在构建了键的最新版本映射后，Bitcask 会打开一个新的数据文件（通常称为“合并文件”或“新文件”），并将映射中的所有最新版本的数据条目写入这个新文件。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;丢弃旧数据条目&lt;/strong&gt; ：由于新文件中已经包含了所有键的最新版本，旧的、过时的数据条目在写入新文件后就不再需要了。因此，这些旧数据条目会被丢弃。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;更新&lt;/strong&gt; &lt;code&gt;keydir&lt;/code&gt; ：在合并过程中，Bitcask 会更新内存中的 &lt;code&gt;keydir&lt;/code&gt;，使其指向新文件中的最新数据条目。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;删除旧文件&lt;/strong&gt; ：合并完成后，Bitcask 会删除旧的非活跃文件，因为这些文件中的数据已经被合并到新文件中。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;创建提示文件&lt;/strong&gt; ：为了加速未来的启动时间，Bitcask 会为新文件创建提示文件。提示文件记录了每个键在新文件中的位置和大小，但不包含实际的值。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/database/bitcask-merge-process.png&#34; alt=&#34;图7 合并流程&#34; srcset=&#34;http://localhost:1313/images/database/bitcask-merge-process.png?size=small, http://localhost:1313/images/database/bitcask-merge-process.png?size=medium 1.5x, http://localhost:1313/images/database/bitcask-merge-process.png?size=large 2x&#34; data-title=&#34;图7 合并流程&#34; style=&#34;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;figcaption class=&#34;image-caption&#34;&gt;图7 合并流程&lt;/figcaption&gt;&#xD;&#xA;  &lt;/figure&gt;&lt;/p&gt;&#xA;&lt;p&gt;总结来说，合并过程通过读取所有非活跃文件，构建键的最新版本映射，并将这些最新版本的数据条目写入新文件，从而丢弃旧的、过时的数据条目。这个过程有效地减少了存储空间的占用，并通过生成的提示文件加速了 Bitcask 的启动时间。&lt;/p&gt;&#xA;&lt;h3 id=&#34;备份与恢复过程&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;备份与恢复过程&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%e5%a4%87%e4%bb%bd%e4%b8%8e%e6%81%a2%e5%a4%8d%e8%bf%87%e7%a8%8b&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;完善中&lt;/p&gt;&#xA;&lt;h2 id=&#34;与lsm-tree对比&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;与lsm-tree对比&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%e4%b8%8elsm-tree%e5%af%b9%e6%af%94&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;Bitcask 和 LSM-Tree（Log-Structured Merge-Tree）是两种常见的键值存储引擎，它们各自有不同的优缺点，适用于不同的应用场景。以下是它们的主要优缺点对比：&lt;/p&gt;&#xA;&lt;h3 id=&#34;bitcask&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;Bitcask&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#bitcask&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;简单高效&lt;/strong&gt; ：Bitcask 模型非常简单，易于理解和实现。它基于日志结构，数据写入速度非常快，因为写操作是顺序的，减少了磁盘寻道时间。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;快速读取&lt;/strong&gt; ：由于 Bitcask 维护了一个内存中的哈希表（称为“键目录”），读取操作非常快，通常只需要一次内存查找。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;低延迟写入&lt;/strong&gt; ：写入操作是直接追加到日志文件中，不需要复杂的合并操作，因此写入延迟较低。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;易于备份和恢复&lt;/strong&gt; ：Bitcask 的数据文件是顺序的，易于备份和恢复。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;内存占用&lt;/strong&gt; ：Bitcask 需要维护一个内存中的哈希表来存储键和数据文件的偏移量，这会占用大量内存，尤其是在键数量巨大的情况下。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;磁盘空间利用率&lt;/strong&gt; ：Bitcask 不支持原地更新，旧数据不会被覆盖，因此随着时间的推移，磁盘空间利用率会逐渐降低。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;不支持范围查询&lt;/strong&gt; ：Bitcask 是基于键值对的存储，不支持高效的范围查询。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;lsm-tree&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;LSM-Tree&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#lsm-tree&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;高写入吞吐量&lt;/strong&gt; ：LSM-Tree 通过将写操作先写入内存中的 MemTable，然后定期刷新到磁盘上的 SSTable（Sorted String Table），实现了高写入吞吐量。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;高效的磁盘空间利用&lt;/strong&gt; ：LSM-Tree 通过合并和压缩操作，可以有效地回收旧数据占用的磁盘空间，提高磁盘利用率。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;支持范围查询&lt;/strong&gt; ：由于数据是按顺序存储在 SSTable 中，LSM-Tree 支持高效的范围查询。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;可扩展性&lt;/strong&gt; ：LSM-Tree 设计支持水平扩展，适合大规模数据存储和高并发写入场景。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;写放大问题&lt;/strong&gt; ：LSM-Tree 的写入操作可能会导致写放大问题，即一次写操作可能会触发多次磁盘写入（例如，合并和压缩操作）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;读取延迟较高&lt;/strong&gt; ：读取操作可能需要合并多个 SSTable 中的数据，尤其是在数据量较大时，读取延迟较高。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;复杂性较高&lt;/strong&gt; ：LSM-Tree 的实现和管理相对复杂，涉及到多个组件（如 MemTable、SSTable、Bloom Filter 等）的协调和管理。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;总结&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;总结&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%e6%80%bb%e7%bb%93&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Bitcask&lt;/strong&gt; 适合于写入频繁、读取频繁但不需要范围查询的场景，尤其是在内存充足的情况下。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;LSM-Tree&lt;/strong&gt; 适合于需要高写入吞吐量、支持范围查询、并且可以容忍一定读取延迟的场景。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;参考文献&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;参考文献&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://riak.com/assets/bitcask-intro.pdf&#34;target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;https://riak.com/assets/bitcask-intro.pdf&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;]]></description>
    </item>
  </channel>
</rss>
